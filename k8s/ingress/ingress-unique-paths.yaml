apiVersion: kubevious.io/v1alpha1
kind: ClusterRule
metadata:
  name: ingress-unique-paths
spec:
  summary: |
    Validate Ingress TLS and rule domain match.
  target: |
    Union(
      Api('networking.k8s.io')
        .Kind('Ingress'),
      Api('extensions')
        .Kind('Ingress')
    )
  globalCache: |
    cache.rules = {};
    cache.manifests = {};

    for(const item of Union(
                        Api('networking.k8s.io')
                          .Kind('Ingress'),
                        Api('extensions')
                          .Kind('Ingress')
                      ).many())
    {
      for(const rule of item.config.spec?.rules ?? [])
      {
        for(const path of rule?.http?.paths ?? [])
        {
          register(item, {
                           host: rule.host, 
                           path: path.path, 
                           pathType: path.pathType, 
                         });
        }
      }
    }

    // HELPERS
    function register(item, info)
    {
      if (!cache.manifests[item.manifest.idKey]) {
        cache.manifests[item.manifest.idKey] = {}
      }

      const key = _.stableStringify(info);
      cache.manifests[item.manifest.idKey][key] = info;

      if (!cache.rules[key]) {
        cache.rules[key] = {};
      }
      cache.rules[key][item.manifest.idKey] = true;
    }

  rule: |
    // error(`rules: ${JSON.stringify(globalCache.rules)}`);
    // error(`manifests: ${JSON.stringify(globalCache.manifests)}`);

    const myRules = globalCache.manifests[item.manifest.idKey];

    for(const ruleKey of _.keys(myRules))
    {
      //error(ruleKey);
      const others = globalCache.rules[ruleKey];
      if (_.keys(others).length > 1)
      {
        error(`Duplicate Ingress rule found. ${ruleKey}`);
      }
    }


  application:
    clustered: true    